# Java Final

## 问答题

* 重写与重载的区别
  1. 相同点：函数名相同
  2. 不同点：重载要求有不同的方法签名，即参数列表必须不同，返回值类型和访问修饰符都可以不同，抛出的异常也可以不同 ，主要指一个类之中的重载，当然也可以子类对父类的同名方法进行重载；重写是子类对父类相同方法签名的方法的重新定义，重写方法的返回值类型必须相同，重写方法的访问修饰符权限一定要大于被重写方法的访问修饰符权限，重写方法抛出的异常一定是被重写方法抛出异常的子类或者相同；
  3. 其他：被重写之后如果要调用父类中原来的被重写方法，可以使用`super`关键字，也可以使用`ClassName.method()`；构造方法必须和类名相同，因此只能被重载而不能被重写
* 多态、动态绑定
  1. 多态：同一个行为具有不同表现形式；实现方式：重写、接口、抽象类和抽象方法
  2. 静态绑定：在编译阶段就已经确定调用方法在常量池中的引用，`static-不依赖对象, final-可继承不重写, private-不可继承`
  3. 动态绑定：编译时类型和运行时类型不一致的时候；JVM会自底向上依次查找该调用方法的实现；
  4. 重载使用静态绑定，而重写使用动态绑定；
* 接口、抽象类
  1. 抽象类：抽象类中可以有抽象方法也可以没有，抽象方法必须是`public, protected`，抽象类不能实例化，如果一个子类没有实现全部其父类的抽象方法，那其必须定义为抽象类；`class Dog extends Animals`
  2. 接口：接口中的变量会被隐式地指定为`public static final`，方法则是`public abstract`，接口中只能由抽象方法，运行一个类实现多个接口；`class Dog implements Cloneable, Comparable`
  3. 相同：二者都不可以实例化
* 静态、实例变量
  * 实例变量属于某个对象，只有创建对象后才会为变量分配空间；储存在堆中；
  * 静态变量不属于某个实例变量，而是整个类，只要加载了类的字节码就会被分配空间和使用，不论创建多少对象，静态变量都只有一份；语法上静态变量需要用`static`修饰，可以直接用类名来访问；储存在方法区中；
* final修饰变量、方法、类
  1. `final`修饰类：类不能被继承，
  2. `final`修饰变量：变量相当于常量
  3. `final`修饰方法：方法不能被重写

## 编程题

* 反转链表
  * 引入两个辅助结点，然后再利用好头结点的空指针
* 压栈弹出
* 层次遍历二叉树
  * 用队列实现即可，关键语句`while(!queue.isEmpty()){}`循环
* 八皇后

  1. `genqueen(int[] queen, int currentrow)`
     * 如果放到最后一行则输出
     * 给该行每个位置都放一遍，如果合法则递归调用放下一行
     * 否则就不做任何操作
  2. `islegalpos(int[] queen, int currentrow, int currentcol)`
     * 判断当前位置是否合法

